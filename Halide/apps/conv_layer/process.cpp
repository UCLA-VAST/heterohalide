#include <cstdio>
#include <chrono>

#include "conv_layer.h"
#include "conv_layer_auto_schedule.h"

#include "halide_benchmark.h"
#include "HalideBuffer.h"

#include <iostream>
#include <fstream>

using namespace Halide::Tools;
using namespace Halide::Runtime;

using namespace std;

int main(int argc, char **argv) {
    Buffer<float> input(67, 67, 32, 4); // width, height, channels, dim(3).extent
    Buffer<float> filter(3, 3, 32, 32);
    Buffer<float> bias(32);

    // original
    // for (int c = 0; c < input.dim(3).extent(); c++) {
    //     for (int z = 0; z < input.channels(); z++) {
    //         for (int y = 0; y < input.height(); y++) {
    //             for (int x = 0; x < input.width(); x++) {
    //                 input(x, y, z, c) = rand();
    //                 // cout << input(x,y,z,c) << '\t';
    //             }
    //         }
    //     }
    // }
    // cout << input.dim(3).extent() << endl << input.dim(3).min() << endl;

    // for (int c = 0; c < filter.dim(3).extent(); c++) {
    //     for (int z = 0; z < filter.channels(); z++) {
    //         for (int y = 0; y < filter.height(); y++) {
    //             for (int x = 0; x < filter.width(); x++) {
    //                 filter(x, y, z, c) = rand();
    //             }
    //         }
    //     }
    // }

    // for (int x = 0; x < bias.width(); x++) {
    //     bias(x) = rand();
    // }

    // read from txt file generated by app_halide2heterocl/conv/rand_generate.py
    ifstream input_file ("/curr/jiajieli/app_halide2heterocl/conv/input.txt");
    for (int c = 0; c < input.dim(3).extent(); c++) {
        for (int z = 0; z < input.channels(); z++) {
            for (int y = 0; y < input.height(); y++) {
                for (int x = 0; x < input.width(); x++) {
                    input_file >> input(x, y, z, c);
                }
                //cout << '\n';
            }
            //cout << '\n';
        }
        //cout << '\n';
    }

    ifstream filter_file ("/curr/jiajieli/app_halide2heterocl/conv/filter.txt");
    for (int c = 0; c < filter.dim(3).extent(); c++) {
        for (int z = 0; z < filter.channels(); z++) {
            for (int y = 0; y < filter.height(); y++) {
                for (int x = 0; x < filter.width(); x++) {
                    filter_file >> filter(x, y, z, c);
                    // cout << filter(x,y,z,c) << '\t';
                }
                // cout << '\n';
            }
            // cout << '\n';
        }
        // cout << '\n';
    }

    ifstream bias_file ("/curr/jiajieli/app_halide2heterocl/conv/bias.txt");
    for (int x = 0; x < bias.width(); x++) {
        bias_file >> bias(x);
    }

    Buffer<float> output(64, 64, 32, 4);

    conv_layer(input, filter, bias, output);

    // Timing code

    // Manually-tuned version
    double min_t_manual = benchmark(10, 10, [&]() {
        conv_layer(input, filter, bias, output);
    });
    printf("Manually-tuned time: %gms\n", min_t_manual * 1e3);

    // Auto-scheduled version
    double min_t_auto = benchmark(10, 10, [&]() {
        conv_layer_auto_schedule(input, filter, bias, output);
    });
    printf("Auto-scheduled time: %gms\n", min_t_auto * 1e3);

    // write output to txt file
    // cout << output.dim(3).extent() << " , " << output.channels() << " , " << output.height() << " , " << output.width() << endl;
    ofstream output_file ("/curr/jiajieli/app_halide2heterocl/conv/output_halide.txt");
    for (int c = 0; c < output.dim(3).extent(); c++) {
        for (int z = 0; z < output.channels(); z++) {
            for (int y = 0; y < output.height(); y++) {
                for (int x = 0; x < output.width(); x++) {
                    output_file << output(x, y, z, c) << '\t';
                }
            }
        }
    }    

    return 0;
}
