# Plan
## rebuttal
1. Test the performance of auto-scheduling
2. Comparison with xfOpenCV
3. Energy efficiency comparison (usually we can use the performance numbers and the thermal design power to obtain energy comparison)

## Other 
1. Support all the application in the paper and give them all a performance report
    1. Dilation
    2. Erosion
    3. Median Blur
    4. Sobel
    5. Conv
2. Test again the performance for HeteroCL code generated by Imperative DSL
    1. Blur
    2. Linear Blur
    3. Stencil Chain
    4. Harris
    5. Gaussian
    6. Unsharp (support multiple input / output version?)
3. Support the schedules
    1. reorder
    2. split
    3. fuse
    4. tile
    5. unroll
    6. parallel

## Long term
1. make compute_root as a default schedule
2. create a switch to control whether use original Halide (all optimizations on) or HeteroHalide (some optimizations off, e.g. storage flatten, unroll, parallel)

# Bugs & Problems
## SODA backend
1. SODA code generated by HeteroCL code remains the "initial 0" term, and SODA backend doesn't support "conflicting stmt name" now. 
    1. Solution: remove the "initial 0" term manually
    2. This removal is supposed to be done in "HeteroCL -> SODA code" step. But it's not clear why it fails to do so. 

## HeteroCL code testing
1. Harris
    Compare the results, again the bug comes from "cim" operation. I think this comes from type transformation, so we just ignore it for now. It is not related to the new transformation rules. 

## Result
1. Linear_Blur
    BRAM 3504 (RAMB36 1744 + RAMB18 16), which is very high? But the SODA code seems the same as the former one (using old transformation rules)

# New
## Rules
1. need to add a "final stage" which is equal to the last stage, because the last stage in Halide IR doesn't have a Realize node so that we can't know its Type information. To make the last two stage totally equal, we just copy from the Type information from the "second to last" stage for the "final stage". 

2. Temporary Solution
To deal with "Final stage", one solution is: we collect information in "Realize", and print hcl.compute(lambda: 0) in Producer      

This works if "Produce" and "Realize" always occur at the same time.    
Still, I need to clean the code in "Realize" (haven't yet)  


## Write HeteroCL code manually with Imperative DSL
### Works
1. blur
2. conv
3. linear_blur
4. stencil_chain

## New Transformation Rules
### Folders and Files
1. xxx_target.py
目标的Imperative DSL生成HeteroCL代码
2. xxx_generate.py
HeteroCL code generated by original transformation rules
3. xxx_gen.py
HeteroCL code generated by new transformation rules

### Change Nodes
1. Realize
2. ProducerConsumer
3. For
4. Call
5. Provide
6. Let

### Testcases
1. Blur (done)
2. Linear_blur (done)
3. Conv (done)
4. Stencil (done)

# Result
## Speedup vs CPU
### Original Transformation Rule
| Benchmark | Data Sizes & Type | FPGA Maximum Throughput | LUT | FF | DSP | BRAM | CPU rate (pixels/ns) | Speedup (Assume Frequency=300MHz) = (throughput * 300M) / (total pixels / total cpu time) |
| --------  | --- | -- | -- | --- | ---- | --- | --- | --- |
| Total  | board: U250 | | 1728000 | 3456000 | 12288 | 5376 |  |  |
| Harris | 2448 * 3264, UInt8 | 32 | 216115 (12.5%) | 276954 (8.0%) | 1056 (8.6%) | 320 (5.95%) | 0.77636 | 12.37 |
| Gaussian | 2160 * 3840, UInt8 | 32 | 125302 (7.3%) | 89460 (2.6%) | 1536 (12.5%) | 0 (0%) | 1.3167 | 7.29 |
| Unsharp | 2448 * 3264 * 3, UInt8 | 32 | 167740 (9.7%) | 132822 (3.8%) | 1600 (13.0%) | 96 (1.8%) | AOT: 2.35954(pix/ns) |  4.07 |
| Blur | 648 * 482, UInt16 | 16 | 6789 (0.4%) | 8209 (0.2%) | 32 (0.3%) | 0 (0%) | 1.0275507 | 4.67 |
| Linear Blur | 768 * 1280 * 3, float32 | 8 | 30407 (1.8%) | 50017 (1.4%) | 536 (4.4%) | 16 (0.3%) | 0.446711 | 5.3726 |
| Stencil_Chain (stage num = 3) | 1536 * 2560, UInt16 | 16 | 61531 (3.6%) | 49006 (1.4%) | 48 (0.4%) | 192 (3.6%) | 2.640905 | 1.82 | 
| New Benchmark | - | - | - | - | - | - | - | - |
| Median Blur | 6478 * 4818, UInt8 | 16 | 7399 | 6298 | 0 | 32 | - | - |
| Median Blur | 6478 * 4818, UInt8 | 32 (max) | 14469 (0.8%) | 12148 (0.35%) | 0 | 64 (1.2%) | - | - |

### New Transformation Rule (usually Burst Width = 256 = input width; bandwidth restricted: input width + output width = 512 (max))
| Benchmark | Data Sizes & Type | FPGA Maximum Throughput | LUT | FF | DSP | BRAM | CPU rate (pixels/ns) | Speedup (Assume Frequency=300MHz) = (throughput * 300M) / (total pixels / total cpu time) |
| --------  | --- | -- | -- | --- | ---- | --- | --- | --- |
| Total  | board: U250 | | 1728000 | 3456000 | 12288 | 5376 |  |  |
| Blur | 640 * 480, UInt16 | 16| 6789 | 8209 | 32 | 0 (0%) |  |  |
| Linear Blur | 768 * 1280 * 3, float32 | 8 | 37650 | 53923 | 536 | 3504 |  |  |
| Stencil_Chain (stage num = 3) | 1536 * 2560, UInt16 | 16 | 58854 | 49016 | 48 | 192 |  |  | 
| New Benchmark | - | - | - | - | - | - | - | - |
| Median Blur | 6478 * 4818, UInt8 | 16 |  |  |  |  | - | - |
| Median Blur | 6478 * 4818, UInt8 | 32 (max) |  |  |  |  | - | - |