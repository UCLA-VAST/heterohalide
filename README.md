# Paper revision

## TODO 12-20
1. KMeans support
2. LeNet fully support
3. Figure out if it is possible to direct compile in the 'Generate' style of Halide code.   
Currently we have to write in the Just-In-Time compilation method? Try the AOT compilation.     

## New Experiments
use SODA backend (hand-written) or Merlin backend?
1. Dilation (handwritten SODA code)
2. Erosion (handwritten SODA code)
3. Sobel (handwritten SODA, but fail to run?)

## address Merlin backend
how to compare Merlin and SODA? How to use Merlin's DSE (design space exploration)? 
1. Conv_layer     

## Energy efficiency metrics (yes)

## Auto-schedule

## technical improvement to the Halide-HLS (yes)

# Need to be attention
1. when testing, need the input and output data type: uint16 or larger. Uint8 will cause unexpected error......
2. Burstwidth and Unroll factor
    1. Usually (one input and one output): Maximum bandwidth = 512. input burstwidth + output burstwidth <= 512. -> burstwidth = 256 = unroll_factor * bits of one input data
    2. multiple input and multiple output: how to calculate? forget......
3. HeteroCL coding
    1. Need to wrap the tensor assignment with a HeteroCL stage.
    Correct HeteroCL code:    
    ```
    def top(input, ):
    blur_x = hcl.compute((640, (480 + 2)), lambda x, y: 0, name = "blur_x", dtype = hcl.UInt(bits = 16))
    with hcl.Stage("s1"):
        blur_x[5, 5] = 2
    ```
4. Add Optimization Switch
    1. Generate HeteroCL code   
        need to have `#define _CODEGEN_HETEROCL_GENERATE` in 'Halide/src/Lower.cpp' file.       
        in run_application.sh (e.g. run_blur.sh), we use shell function `sed` to add and remove `#define _CODEGEN_HETEROCL_GENERATE`. 
    2. Having `#define _CODEGEN_HETEROCL_GENERATE`
        1. close Storage_Flatten
        2. close Unroll & Vectorize optimizations
5. Halide RDom scheduling
    1. when scheduling with RDom, need .update() first. 
    2. RVar as a spliting factor of ReductionVar

# Plan
## Comments from reviewers
### Reviewer 1
1. Different backends from HeteroCL (*) More applications targeted to (not only SODA?)
2. Novelty compared to Halide-HLS
### Reviewer 2
1. contributioin beyond a Halide-to-HeteroCL code generator
2. HLS Generated very large #LoC in Table 3. Not valuable comparison. 
### Reviewer 3
1. disappointed that the methodology needs to rely on commercial HLS tools to generate RTL at the final step. (Response: HeteroCL is open-source. So our HeteroHalide is fully open-source, right? )
2. Auto-scheduling
3. Other metrics: latency, energy efficiency
4. Comparison with Halide-HLS
5. Comparison with xfOpenCV
6. Besides #LoC, maybe should consider the number of pipelines (stages?) to show the complexity of the benchamrks? 
### Reviewer 4
1. Contribution & Novelty
2. Show more about transformation details: tell the Halide IR system in detail?
3. Comparison with Halide-HLS, technically.
### Reviewer 5
1. Lack some previous works, e.g. work done at Frost workshop at MIT, which support Halide in its FPGA compilation flow. Work from MIT and FixStars: previous Halide to FPGA compilers. 
2. More results against low-level RTL would be interesting, to understand the cost of the abstraction. 

## Rebuttal
1. Test the performance of auto-scheduling
2. Comparison with xfOpenCV (hard to address...)
3. Energy efficiency comparison (usually we can use the performance numbers and the thermal design power to obtain energy comparison): Energy Efficiency = Performance (throughput * frequency: (pixel/cycle) * (cycle/s) = (pixel/s) ) / Power (W)
    1. User Thermal Design Power to represent Power. 
    2. CPU: 2 Intel Xeon 2680v4: 240W (120W each)
    3. FPGA: Xilinx Alveo U250 FPGA: 225W

## Other 
1. Support all the application in the paper and give them all a performance report
    1. Dilation
        Can Generate HeteroCL code (pass test), but can't generate SODA code
    2. Erosion
        Can Generate HeteroCL code (pass test), but can't generate SODA code
    3. Median Blur
        Can Generate HeteroCL code (pass test), but can't generate SODA code
    4. Sobel
        Can Generate HeteroCL code (pass test), but can't generate SODA code
    5. Conv
2. Test again the performance for HeteroCL code generated by Imperative DSL
    1. Blur (done)
    2. Linear Blur (done)
    3. Stencil Chain (done)
    4. Harris (half done)
        1. Can Generate Correct HeteroCL code. But fail to pass the test, because there are some trivial type-transform problems (occured before), I think it doesn't matter actually. 
        2. Have two adjacent For loops in one stage. This structure is not supported by SODA transformer now. Can't generate correct SODA code. 
    5. Gaussian
        1. Can Generate Correct HeteroCL code. Can't generate correct SODA code (SODA bug 2)
    6. Unsharp (support multiple input / output version?) (later)
        1. previous: SODA doesn't support different dimensions between the stages, and in this case, we have dim-3 input and output, but the intermediate stages are dim-2.         
        previous solution: we separate the original dim-3 input and output to 3 dim-2 inputs and outputs. This leads to the problem of multiple inputs and outputs. We didn't handle this problem well for now.         

        We create 3 HeteroCL code files for each dimension, and genereate 3 SODA code files... But of course counting the resources all is wasteful and unreasonable. The performance result is obatined via one dim of the separated dimensions. And the CPU speed is obtained via the orginal dim-3 code. 

        2. We aim to support multiple inputs and outputs in this new version. 
        
        "hcl.update()" function will be a potential solution. But also we need to modify the connection code to let three output Func to be received in CodeGen_HeteroCL. 

3. Support the schedules
    1. reorder (done)
    2. split (done)
        1. seems that using "Division" in hcl.for_(min, extent, name) will cause error.     
            Solution: "/" -> "//". Should be integer division. Always set Div as Interger Division. 
    3. fuse (done)
    4. tile (done)
    5. unroll (done)
    6. parallel (done)

## Long term
1. make compute_root as a default schedule
2. create a switch to control whether use original Halide (all optimizations on) or HeteroHalide (some optimizations off, e.g. storage flatten, unroll, parallel)

# Bugs & Problems
## SODA backend
1. SODA code generated by HeteroCL code remains the "initial 0" term, and SODA backend doesn't support "conflicting stmt name" now. 
    1. Solution: remove the "initial 0" term manually
    2. This removal is supposed to be done in "HeteroCL -> SODA code" step. But it's not clear why it fails to do so. 
2. Can't generate correct SODA code for a certain kind of loop structure: having two adjacent For loops in one stage. This will cause "xxx = 0" in SODA code generated. 
    1. Waiting for the solution. 

## HeteroCL code testing
1. Harris
    Compare the results, again the bug comes from "cim" operation. I think this comes from type transformation, so we just ignore it for now. It is not related to the new transformation rules. 

## Result
1. Linear_Blur
    BRAM 3504 (RAMB36 1744 + RAMB18 16), which is very high? But the SODA code seems the same as the former one (using old transformation rules)

# New
## Rules
1. need to add a "final stage" which is equal to the last stage, because the last stage in Halide IR doesn't have a Realize node so that we can't know its Type information. To make the last two stage totally equal, we just copy from the Type information from the "second to last" stage for the "final stage". 

2. Temporary Solution
To deal with "Final stage", one solution is: we collect information in "Realize", and print hcl.compute(lambda: 0) in Producer      

This works if "Produce" and "Realize" always occur at the same time.    
Still, I need to clean the code in "Realize" (haven't yet)  


## Write HeteroCL code manually with Imperative DSL
### Works
1. blur
2. conv
3. linear_blur
4. stencil_chain

## New Transformation Rules
### Folders and Files
1. xxx_target.py
目标的Imperative DSL生成HeteroCL代码
2. xxx_generate.py
HeteroCL code generated by original transformation rules
3. xxx_gen.py
HeteroCL code generated by new transformation rules

### Change Nodes
1. Realize
2. ProducerConsumer
3. For
4. Call
5. Provide
6. Let
7. LetStmt
8. Div ("/" -> "//")

### Testcases
1. Blur (done)
2. Linear_blur (done)
3. Conv (done)
4. Stencil (done)

# Result
## Speedup vs CPU
### FPGA: use AWS-F1 platform
| Benchmark | Data Sizes & Type | FPGA Maximum Throughput | LUT | FF | DSP | BRAM | CPU rate (pixels/ns) | Speedup (Assume Frequency=250MHz) = (throughput * 250M) / (total pixels / total cpu time) | CPU Energy Efficiency (pixel / (ms×W)) = Speed (pixel/ms) / Power (W) | FPGA Energy Efficiency (pixel / (ms×W)) = Speed (pixel/ms) / Power (W) | Energy Efficiency Gain | Backend |
| --------  | --- | -- | -- | --- | ---- | --- | --- | --- | --- | --- | --- | --- |
| Total  | board: F1 | | unknown | - | - | - |  |  | TDP(CPU) = 240W | TDP(FPGA) = 85W | FPGA_Energy_Efficiency / CPU_Energy_Efficiency = Speedup * TDP (CPU) / TDP (FPGA) | SODA/Merlin/Systolic Array |
| Harris | 2448 * 3264, UInt8 | 32 | 55198 | 64427 | 264 | 80 | 0.77636 | 10.31 | 3234.83 | 42666.67 | 13.19 | SODA |
| Gaussian | 2160 * 3840, UInt8 | 32 | 67298 | 41496 | 768 | 0 (0%) | 1.3167 | 6.08 | 5486.25 | 42666.67 | 7.78 | SODA |
| Unsharp | 2448 * 3264 * 3, UInt8 | 32 | 47683 | 33114 | 400 | 24 | AOT: 2.35954(pix/ns) |  3.39 | 9831.42 | 42666.67 | 4.34 | SODA |
| Blur | 648 * 482, UInt16 | 16 | 6821 | 8209 | 32 | 0 | 1.0275507 | 3.89 | 4281.46 | 21333.33 | 4.98 | SODA |
| Linear Blur | 768 * 1280 * 3, float32 | 8 | 31049 | 39369 | 536 | 16 | 0.446711 | 4.48 | 1861.296 | 10666.67 | 5.73 | SODA | 
| Stencil_Chain (stage num = 3) | 1536 * 2560, UInt16 | 16 | 61230 | 46174 | 48 | 192 | 2.640905 | 1.52 | 11003.77 | 21333.33 | 1.94 | SODA |
| New Benchmark | - | - | - | - | - | - | - | - | - | - | - | - |
| Median Blur | 6480 * 4820, UInt8 | 32 | 14388 | 10066 | 0 | 64 | 1.80925 | 4.43 | - | - | 5.66 | SODA |
| Dilation | 6480 * 4820, UInt8 | 32 | 13046 | 12114 | 0 | 64 | 4.83124 | 1.66 | - | - | 2.12 | SODA |
| Erosion | 6480 * 4820, UInt8 | 32 | 13046 | 12114 | 0 | 64 | 4.94529 | 1.62 | - | - | 2.07 | SODA |
| Sobel | 6480 * 4820, Int16 | 16 | 11311 | 10928 | 0 | 48 |  |  |  |  |  | SODA |
| HeteroCL result | FPGA runtime | - | - | - | - | - | CPU runtime | Speedup = CPU runtime / FPGA runtime | - | - | - | - |
| GEMM | 1024 * 1024 * 1024, Int16 | 2.659ms | 454492 | 800283 | 2057 | 932 | 7263908ns | 3.53 | 
| LeNet | - | 0.058ms | 362291 | 660186 | 1368 | 739.5 | - | 
| K-means | ClutseringK=16 | 3.747ms | 212708 | 235011 | 1536 | 32 | - | 



### Original Transformation Rule
| Benchmark | Data Sizes & Type | FPGA Maximum Throughput | LUT | FF | DSP | BRAM | CPU rate (pixels/ns) | Speedup (Assume Frequency=300MHz) = (throughput * 300M) / (total pixels / total cpu time) | CPU Energy Efficiency (pixel / (ms×W)) = Speed (pixel/ms) / Power (W) | FPGA Energy Efficiency (pixel / (ms×W)) = Speed (pixel/ms) / Power (W) | Energy Efficiency Gain | Backend |
| --------  | --- | -- | -- | --- | ---- | --- | --- | --- | --- | --- | --- | --- |
| Total  | board: U250 | | 1728000 | 3456000 | 12288 | 5376 |  |  | TDP(CPU) = 240W | TDP(FPGA) = 225W | FPGA_Energy_Efficiency / CPU_Energy_Efficiency | SODA/Merlin/Systolic Array |
| Harris | 2448 * 3264, UInt8 | 32 | 216115 (12.5%) | 276954 (8.0%) | 1056 (8.6%) | 320 (5.95%) | 0.77636 | 12.37 | 3234.83 | 42666.67 | 13.19 | SODA |
| Gaussian | 2160 * 3840, UInt8 | 32 | 125302 (7.3%) | 89460 (2.6%) | 1536 (12.5%) | 0 (0%) | 1.3167 | 7.29 | 5486.25 | 42666.67 | 7.78 | SODA |
| Unsharp | 2448 * 3264 * 3, UInt8 | 32 | 167740 (9.7%) | 132822 (3.8%) | 1600 (13.0%) | 96 (1.8%) | AOT: 2.35954(pix/ns) |  4.07 | 9831.42 | 42666.67 | 4.34 | SODA |
| Blur | 648 * 482, UInt16 | 16 | 6789 (0.4%) | 8209 (0.2%) | 32 (0.3%) | 0 (0%) | 1.0275507 | 4.67 | 4281.46 | 21333.33 | 4.98 | SODA |
| Linear Blur | 768 * 1280 * 3, float32 | 8 | 30407 (1.8%) | 50017 (1.4%) | 536 (4.4%) | 16 (0.3%) | 0.446711 | 5.3726 | 1861.296 | 10666.67 | 5.73 | SODA |
| Stencil_Chain (stage num = 3) | 1536 * 2560, UInt16 | 16 | 61531 (3.6%) | 49006 (1.4%) | 48 (0.4%) | 192 (3.6%) | 2.640905 | 1.82 | 11003.77 | 21333.33 | 1.94 | SODA |
| New Benchmark | - | - | - | - | - | - | - | - | - | - | - | - \
| Median Blur | 6480 * 4820, UInt8 | 32 | 14307 (0.8%) | 11890 (0.34%) | 0 | 64 (1.2%) | 1.80925 | 5.31 | - | - | 5.66 | SODA |
| Dilation | 6480 * 4820, UInt8 | 32 | 12357 (0.7%) | 13106 (0.38%) | 0 | 64 (1.2%) | 4.83124 | 1.99 | - | - | 2.12 | SODA |
| Erosion | 6480 * 4820, UInt8 | 32 | 12357 (0.7%) | 13106 (0.38%) | 0 | 64 (1.2%) | 4.94529 | 1.94 | - | - | 2.07 | SODA |
| Sobel | 6480 * 4820, Int16 | 16 | 11290 (0.7%) | 11952 (0.3%) | 0 | 48 (0.9%) |  |  | SODA |

### New Transformation Rule (usually Burst Width = 256 = input width; bandwidth restricted: input width + output width = 512 (max))
| Benchmark | Data Sizes & Type | FPGA Maximum Throughput | LUT | FF | DSP | BRAM | CPU rate (pixels/ns) | Speedup (Assume Frequency=300MHz) = (throughput * 300M) / (total pixels / total cpu time) |
| --------  | --- | -- | -- | --- | ---- | --- | --- | --- |
| Total  | board: U250 | | 1728000 | 3456000 | 12288 | 5376 |  |  |
| Blur | 640 * 480, UInt16 | 16| 6789 | 8209 | 32 | 0 (0%) |  |  |
| Linear Blur | 768 * 1280 * 3, float32 | 8 | 37650 | 53923 | 536 | 3504 |  |  |
| Stencil_Chain (stage num = 3) | 1536 * 2560, UInt16 | 16 | 58854 | 49016 | 48 | 192 |  |  | 
| Dilation | - | - | - | - | - | - | - | - |
| Erosion | - | - | - | - | - | - | - | - |
| Median Blur | - | - | - | - | - | - | - | - |
| Sobel | - | - | - | - | - | - | - | - |
| Harris | 2448 * 3264, UInt8 | 32 | 216115 (12.5%) | 276954 (8.0%) | 1056 (8.6%) | 320 (5.95%) | 0.77636 | 12.37 |
| Gaussian | 2160 * 3840, UInt8 | 32 | 125302 (7.3%) | 89460 (2.6%) | 1536 (12.5%) | 0 (0%) | 1.3167 | 7.29 |
| Unsharp | 2448 * 3264 * 3, UInt8 | 32 | 167740 (9.7%) | 132822 (3.8%) | 1600 (13.0%) | 96 (1.8%) | AOT: 2.35954(pix/ns) |  4.07 |


# Experiment on Auto-Schedule
the input size and manual schedule of the following testcases are the same as the testcases in the paper. But we use different method to calculate CPU time.    
1. Paper: AOT compilation
2. Following: Halide_Register_Generator 

| Application | Input Size ( = Estimate Size for auto-schedule) | Auto-schedule time (ms) | Manual-schedule time (ms) | total time ratio Auto / Manual; Speed ratio Manual / Auto |
| --- | --- | --- | --- | --- |
| Blur |  |  | Split factor = 8 | Geo Mean: 5.90 |
| Blur | 200*150 | 1.56 | 0.15 | 10.4 | 
| Blur | 300*200 | 1.66 | 0.155 | 10.7 |
| Blur | 400*300 | 2.31 | 0.32 | 7.22 |
| Blur | 648*482 | 0.92 | 0.61 | 1.51 |
| Linear Blur |  |  | split factor = 8 (one stage) | Geo Mean: 0.40 | 
| Linear Blur | 300 * 500 * 3 | 1.13 | 2.67 | 0.42 |
| Linear Blur | 400 * 600 * 3 | 1.21 | 3.18 | 0.38 |
| Linear Blur | 500 * 800 * 3 | 1.42 | 4.53 | 0.31 | 
| Linear Blur | 768 * 1280 * 3 | 3.83 | 7.13 | 0.54 |
| Stencil Chain |  |  | tile size: 512, vectorize: 16 | Geo Mean: 0.64 |
| Stencil Chain | 600 * 1000 | 0.69 | 1.76 | 0.39 |
| Stencil Chain | 800 * 1200 | 0.96 | 1.92 | 0.5 |
| Stencil Chain | 1000 * 1500 | 1.62 | 1.84 | 0.88 |
| Stencil Chain | 1000 * 2000 | 1.39 | 2.00 | 0.695 |
| Stencil Chain | 1300 * 2000 | 1.64 | 1.87 | 0.88 |
| Stencil Chain | 1536 * 2560 | 2.25 | 3.54 | 0.64 |
| Gaussian | | Auto-schedule failed: cannot auto-schedule function "sum_x" since dim"0" at stage 1 has been reordered | tile size: 256 * 64 |  |
<!-- | Gaussian | 1000 * 1500 |  |  |  | 
| Gaussian | 1500 * 2500 |  |  |  | 
| Gaussian | 1800 * 3000 |  |  |  | 
| Gaussian | 2160 * 3840 |  |  |  |  -->


# Intel FPGA OpenCL code / SODA flow
| Benchmark | Data Sizes & Type | FPGA Maximum Throughput | ALUT | FF | RAMs | DSPs | MLABs | CPU rate (pixels/ns) | Speedup (Assume Frequency=480MHz) = (throughput * 480M) / (total pixels / total cpu time) | Energy Efficiency Gain | Backend |
| --------  | --- | -- | -- | --- | ---- | --- | --- | --- | --- | --- | --- | --- | --- |
| Total  | Target Family: Intel Stratix 10; Device: 1SM21BHU2F53E2VGS1; Board: s10mx_ref:s10mx_hbm; Freq: 480 (432)| - | 1405440 | 2810880 | 6847 | 3960 | 0 | | | TDP(CPU) = 240W; TDP(FPGA) = ??W; FPGA_Energy_Efficiency / CPU_Energy_Efficiency = Speedup * TDP (CPU) / TDP (FPGA) | SODA/Merlin/Systolic Array |
| Harris | 2448 * 3264, UInt8 | 16 | 177958 (13%) | 328071 (12%) | 1797 (26%) | 104 (3%) | 593 | 0.77636 | 9.89 |   | SODA |
| Gaussian (RAM 317% error) - old stat | 2160 * 3840, UInt8 | 16 | 67298 | 41496 | 768 | 0 (0%) | 1.3167 | 6.08 | 5486.25 | 42666.67 | 7.78 | SODA |
| Unsharp (old stat) | 2448 * 3264 * 3, UInt8 | 32 | 47683 | 33114 | 400 | 24 | AOT: 2.35954(pix/ns) |  3.39 | 9831.42 | 42666.67 | 4.34 | SODA |
| Blur | 648 * 482, UInt16 | 16 | 37199 (3%) | 62400 (2%) | 420 (6%) | 0 (0%) | 71 | 1.0275507 | 7.47 |  | SODA |
| Linear Blur | 768 * 1280 * 3, float32 | 8 | 264846 (19%) | 367687 (13%) | 4631 (68%) | 632 (16%) | 1495 | 0.446711 | 8.60 |  | SODA | 
| Stencil_Chain (stage num = 3) | 1536 * 2560, UInt16 | 16 | 124317 (9%) | 238908 (8%) | 1989 (29%) | 24 (1%) | 251 | 2.640905 | 2.91 |  | SODA |
| Dilation | 6480 * 4820, UInt8 | 16 | 35621 (3%) | 51676 (2%) | 444 (6%) | 0 (0%) | 30 | 4.83124 | 1.59 |  | SODA |
| Median Blur | 6480 * 4820, UInt8 | 16 | 33973 (2%) | 50140 (2%) | 588 (9%) | 0(0%) | 30 | 1.80925 | 4.24 |  | SODA |



| Erosion | 6480 * 4820, UInt8 | 32 | 13046 | 12114 | 0 | 64 | 4.94529 | 1.62 | - | - | 2.07 | SODA |
| Sobel | 6480 * 4820, Int16 | 16 | 11311 | 10928 | 0 | 48 |  |  |  |  |  | SODA |
| HeteroCL result | FPGA runtime | - | - | - | - | - | CPU runtime | Speedup = CPU runtime / FPGA runtime | - | - | - | - |
| GEMM | 1024 * 1024 * 1024, Int16 | 2.659ms | 454492 | 800283 | 2057 | 932 | 7263908ns | 3.53 | 
| LeNet | - | 0.058ms | 362291 | 660186 | 1368 | 739.5 | - | 
| K-means | ClutseringK=16 | 3.747ms | 212708 | 235011 | 1536 | 32 | - | 