// AutoSchedule: cannot auto-schedule function "mean_local" since dim "0" at stage 1 has been reordered
#include "Halide.h"
#include <stdio.h>

using namespace Halide;

// We will define a generator to auto-schedule.
class AutoScheduled : public Halide::Generator<AutoScheduled> {
public:
    Input<Buffer<int16_t>> input{"input", 4};
    Input<Buffer<int16_t>> weight_conv1{"weight_conv1", 4};
    Input<Buffer<int16_t>> weight_conv2{"weight_conv2", 4};
    Input<Buffer<int16_t>> weight_fc1{"weight_fc1", 2};
    Input<Buffer<int16_t>> weight_fc2{"weight_fc2", 2};
    // Output<Buffer<int16_t>> prod{"prod", 2};
    Output<Buffer<float>> final{"final", 2};

    void generate() {




    // first conv
    Func conv1("conv1");
    RDom r_conv1(weight_conv1.dim(0).min(), weight_conv1.dim(0).extent(),
        weight_conv1.dim(1).min(), weight_conv1.dim(1).extent(),
        weight_conv1.dim(2).min(), weight_conv1.dim(2).extent());
    conv1(x, y, z, n) += weight_conv1(r_conv1.x, r_conv1.y, r_conv1.z, z) * input(x + r_conv1.x, y + r_conv1.y, r_conv1.z, n);

    Func tanh1("tanh1");
    tanh1(x, y, z, n) = tanh(conv1(x, y, z, n));

    Func pool1_tmp("pool1_tmp");
    RDom r_p1(0, 2, 0, 2); // pooling kernel (2, 2)
    pool1_tmp(x, y, z, n) = maximum(tanh1(x + r_p1.x, y + r_p1.y, z, n));

    Func pool1("pool1");
    int p1_stride_x = 2; int p1_stride_y = 2;
    pool1(x, y, z, n) = pool1_tmp(x * p1_stride_x, y * p1_stride_y, z, n);

    // second conv
    Func conv2("conv2");
    RDom r_conv2(weight_conv2.dim(0).min(), weight_conv2.dim(0).extent(),
        weight_conv2.dim(1).min(), weight_conv2.dim(1).extent(),
        weight_conv2.dim(2).min(), weight_conv2.dim(2).extent());
    conv2(x, y, z, n) += weight_conv2(r_conv2.x, r_conv2.y, r_conv2.z, z) * pool1(x + r_conv2.x, y + r_conv2.y, r_conv2.z, n);

    Func tanh2("tanh2");
    tanh2(x, y, z, n) = tanh(conv2(x, y, z, n));

    Func pool2_tmp("pool2_tmp");
    RDom r_p2(0, 2, 0, 2); // pooling kernel (2, 2)
    pool2_tmp(x, y, z, n) = maximum(tanh2(x + r_p2.x, y + r_p2.y, z, n));

    Func pool2("pool2");
    int p2_stride_x = 2; int p2_stride_y = 2;
    pool2(x, y, z, n) = pool2_tmp(x * p2_stride_x, y * p2_stride_y, z, n);
        
    // first fc
    // pool2: (4, 4, 50, 1000) -> (800, 1000)

    // Func flatten("flatten");
    // flatten(x, y) = pool2(x, y, z, n);

    Func flat("flat");
    flat(x, n) = pool2(x % 4, x / 4 % 4, x / 4 / 4 % 50, n);

    Func fc1("fc1");
    RDom r_fc1(0, weight_fc1.dim(1).extent()); // (0, 800)
    fc1(x, n) += flat(r_fc1.x, n) * weight_fc1(x, r_fc1.x);

    Func tanh3("tanh3");
    tanh3(x, y) = tanh(fc1(x, y));


    // second fc
    Func fc2("fc2");
    RDom r_fc2(0, weight_fc2.dim(1).extent());
    fc2(x, n) += tanh3(r_fc2.x, n) * weight_fc2(x, r_fc2.x);

    // softmax
    RDom r_softmax(0, 10);
    Func exp_vals;
    exp_vals(x, n) = exp(fc2(x, n));
    // Func final("final");
    final(x, n) = exp_vals(x, n) / sum(exp_vals(r_softmax.x, n));
    }

    void schedule() {
        if (auto_schedule) {

            input.dim(0).set_bounds_estimate(0, 28);
            input.dim(1).set_bounds_estimate(0, 28);
            input.dim(2).set_bounds_estimate(0, 1);
            input.dim(3).set_bounds_estimate(0, 500);

            weight_conv1.dim(0).set_bounds_estimate(0, 5);
            weight_conv1.dim(1).set_bounds_estimate(0, 5);
            weight_conv1.dim(2).set_bounds_estimate(0, 1);
            weight_conv1.dim(3).set_bounds_estimate(0, 20);         

            weight_conv2.dim(0).set_bounds_estimate(0, 5);
            weight_conv2.dim(1).set_bounds_estimate(0, 5);
            weight_conv2.dim(2).set_bounds_estimate(0, 20);
            weight_conv2.dim(3).set_bounds_estimate(0, 50);

            weight_fc1.dim(0).set_bounds_estimate(0, 500);
            weight_fc1.dim(1).set_bounds_estimate(0, 800);

            weight_fc2.dim(0).set_bounds_estimate(0, 10);
            weight_fc2.dim(1).set_bounds_estimate(0, 500);

            // prod.estimate(x, 0, 1024)
            //        .estimate(y, 0, 1024);
            final.estimate(x, 0, 10)
                   .estimate(n, 0, 500);                   


        } else {
            // This is where you would declare the schedule you have written by
            // hand or paste the schedule generated by the auto-scheduler.
            // We will use a naive schedule here to compare the performance of
            // the autoschedule with a basic schedule.

            // mean_local.compute_at(final, y)
            //         .vectorize(y, 8);

            // final.compute_root();

            // blur_x.compute_root();
            // blur_y.compute_root();
            // output.compute_root();
        }
    }
private:
    Var x{"x"}, y{"y"}, z{"z"}, n{"n"};

};

// As in lesson 15, we register our generator and then compile this
// file along with tools/GenGen.cpp.
HALIDE_REGISTER_GENERATOR(AutoScheduled, auto_schedule_gen)

// After compiling this file, see how to use it in
