// AutoSchedule: cannot auto-schedule function "mean_local" since dim "0" at stage 1 has been reordered
#include "Halide.h"
#include <stdio.h>

using namespace Halide;

// We will define a generator to auto-schedule.
class AutoScheduled : public Halide::Generator<AutoScheduled> {
public:
    Input<Buffer<uint8_t>>  input{"input", 2};

    Output<Buffer<uint8_t>> final{"final", 2};

    void generate() {

        RDom box(0, 3, 0, 3);
        mean_local(x, y) += input(x + box.x, y + box.y) / (3 * 3); // median_blur.
        final(x, y) = mean_local(x, y);

    }

    void schedule() {
        if (auto_schedule) {

            input.dim(0).set_bounds_estimate(0, 6480);
            input.dim(1).set_bounds_estimate(0, 4820);


            final.estimate(x, 0, 6480)
                   .estimate(y, 0, 4820);


        } else {
            // This is where you would declare the schedule you have written by
            // hand or paste the schedule generated by the auto-scheduler.
            // We will use a naive schedule here to compare the performance of
            // the autoschedule with a basic schedule.

            // mean_local.compute_at(final, y)
            //         .vectorize(y, 8);
            mean_local.compute_root();
            final.compute_root();

            // blur_x.compute_root();
            // blur_y.compute_root();
            // output.compute_root();
        }
    }
private:
    Var x{"x"}, y{"y"};
    Func mean_local{"mean_local"};
};

// As in lesson 15, we register our generator and then compile this
// file along with tools/GenGen.cpp.
HALIDE_REGISTER_GENERATOR(AutoScheduled, auto_schedule_gen)

// After compiling this file, see how to use it in
