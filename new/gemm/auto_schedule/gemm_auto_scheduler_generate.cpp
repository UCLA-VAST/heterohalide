// AutoSchedule: cannot auto-schedule function "mean_local" since dim "0" at stage 1 has been reordered
#include "Halide.h"
#include <stdio.h>

using namespace Halide;

// We will define a generator to auto-schedule.
class AutoScheduled : public Halide::Generator<AutoScheduled> {
public:
    Input<Buffer<int16_t>> A{"A", 2};
    Input<Buffer<int16_t>> B{"B", 2};
    // Output<Buffer<int16_t>> prod{"prod", 2};
    Output<Buffer<int16_t>> final{"final", 2};

    void generate() {

        Var x{"x"}, y{"y"};

        RDom r(0, A.dim(1).extent());
        prod(x, y) += A(x, r) * B(r, y);
        final(x, y) = prod(x, y);
    }

    void schedule() {
        if (auto_schedule) {

            A.dim(0).set_bounds_estimate(0, 1024);
            A.dim(1).set_bounds_estimate(0, 1024);
            B.dim(0).set_bounds_estimate(0, 1024);
            B.dim(1).set_bounds_estimate(0, 1024);            


            // prod.estimate(x, 0, 1024)
            //        .estimate(y, 0, 1024);
            final.estimate(x, 0, 1024)
                   .estimate(y, 0, 1024);                   


        } else {
            // This is where you would declare the schedule you have written by
            // hand or paste the schedule generated by the auto-scheduler.
            // We will use a naive schedule here to compare the performance of
            // the autoschedule with a basic schedule.

            // mean_local.compute_at(final, y)
            //         .vectorize(y, 8);

            // final.compute_root();

            // blur_x.compute_root();
            // blur_y.compute_root();
            // output.compute_root();
        }
    }
private:
    Var x{"x"}, y{"y"};
    Func prod{"prod"};
};

// As in lesson 15, we register our generator and then compile this
// file along with tools/GenGen.cpp.
HALIDE_REGISTER_GENERATOR(AutoScheduled, auto_schedule_gen)

// After compiling this file, see how to use it in
